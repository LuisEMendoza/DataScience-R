[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "index",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "index.html#running-code",
    "href": "index.html#running-code",
    "title": "index",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introducción",
    "section": "",
    "text": "Veamos cuáles son los recursos que debemos descargar e instalar primero."
  },
  {
    "objectID": "intro.html#quarto",
    "href": "intro.html#quarto",
    "title": "Introducción",
    "section": "Prerrequisitos",
    "text": "Prerrequisitos\n\nR\nComencemos instalando R. Esto se hace desde el enlace CRAN y eligiendo la plataforma a usar, ya sea Windows, Mac o Linux. En estos apuntes usamos Linux.\n\n\nRStudio\nR es poderoso, pero por defecto funciona con la consola o terminal. Esto puede echarnos para atrás la primera vez. Sin duda, uno se acostumbra y la domina, pero por comodidad podemos comenzar utilizando un buen IDE, en este caso RStudio. Podemos descargarlo e instalarlo desde aquí.\n\n\nTidyverse\nPor sí mismos, R y RStudio son bastante útiles. Sin embargo, es necesario ampliar sus funcionalidades mediante paquetes, que vienen siendo una especie de añadidos que contienen funciones nuevas. En nuestro caso, será el paquete Tidyverse el que instalaremos. Esto es posible lograrlo de dos maneras, siendo la más sencilla la de copiar y pegar la siguiente línea de código en la consola de RStudio:\ninstall.packages(\"tidyverse\")\nDespués de pegar dicha línea en la consola, presionamos Enter para ejecutarla. Así, R descargará e instalará el paquete (es obvio que debemos tener acceso a internet). Es normal que se tome su tiempo.\nJusto después de la instalación, no es posible usar los paquetes por defecto. Debemos cargarlos usando library(), con el nombre del paquete dentro de los paréntesis. Por ejemplo:\nlibrary(tidyverse)\nDebe aparecer un mensaje que mencione varios nombres, como ggplot2, purr o tibble. Eso significa que se ha cargado correctamente.\nEs importante que no descuidemos la actualidad de estos paquetes. Podemos actualizarlos después de haber cargado el paquete mediante\ntidyverse_update()\nLo cual buscará versiones más recientes y, de haberlas, nos dará unas líneas de código que nos permitirá obtenerlas.\n\n\nPaquete datos\nEn estos apuntes se utilizan datos recuperados de varios cursos. Uno muy importante es precisamente el libro Ciencia de Datos con R, cuyo conjunto de datos se llama, precisamente datos. Desde R es posible instalarlos con\ninstall.packages(\"datos\")"
  },
  {
    "objectID": "intro.html#ejecutando-código",
    "href": "intro.html#ejecutando-código",
    "title": "Introducción",
    "section": "Ejecutando código",
    "text": "Ejecutando código\nSe recomienda que el código que vayamos mostrando se vaya introduciendo y ejecutando en la consola de RStudio. La ventaja de que estos apuntes sean electrónicos es que podemos mostrar el código tal cual pueda ser copiado y pegado en dicha consola. De hecho, hay hasta un botón que permite copiarlo. Identificaremos el código «copiable» porque estará escrito como a continuación:\n1 + 2 \nLocaliza el botón de copiar y presiónalo. Ahora pégalo en tu consola de RStudio. Debes comprobar que te arroja lo siguiente, exactamente como te lo mostramos:\n\n\n[1] 3\n\n\nCabe mencionar que retomamos algunas convenciones del libro ya citado arriba. Entre ellas, se encuentran:\n\nLos nombres de funciones estarán escritos en fuente para código y con un par de paréntesis vacíos enseguida sum();\nLos nombres de datos, de argumentos o de variables irán con la misma fuente, pero sin paréntesis datos, y por último\nSi un objeto viene de un paquete y debemos especificar ambos, vendrá el nombre del paquete, enseguida doble dos puntos y al final el nombre del objeto, por ejemplo dplyr::mutate."
  },
  {
    "objectID": "view.html",
    "href": "view.html",
    "title": "Visualización de datos",
    "section": "",
    "text": "Aunque parezca lo más práctico comenzar con la organización y transformación de los datos, comenzaremos por el otro lado. Veamos primero cómo crear gráficos coherentes y hasta elegantes.\nUtilizaremos el paquete ggplot, que utiliza un sistema conocido como la gramática de gráficos. Carguemos dicho paquete, además del conjunto de datos a utilizar:\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.0     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.1     ✔ tibble    3.2.0\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the \u001b]8;;http://conflicted.r-lib.org/\u0007conflicted package\u001b]8;;\u0007 to force all conflicts to become errors\n\nlibrary(datos)"
  },
  {
    "objectID": "view.html#nuestro-primer-gráfico",
    "href": "view.html#nuestro-primer-gráfico",
    "title": "Visualización de datos",
    "section": "Nuestro primer gráfico",
    "text": "Nuestro primer gráfico\nCrearemos nuestro primer gráfico con ggplot y probaremos con datos reales que a mayor tamaño de motor de un coche, mayor consumo de gasolina tendrá. Para ello, debemos estar seguros de haber cargado correctamente tanto el Tydiverse como el conjunto datos. Enseguida mostraremos un data frame, lo cual es un conjunto rectangular de datos organizados en columnas (que vienen siendo las variables) y filas (éstas son las observaciones). Este data frame es llamado millas, el cual está contenido en datos (datos::millas).\n\nmillas\n\n# A tibble: 234 × 11\n   fabrica…¹ modelo cilin…²  anio cilin…³ trans…⁴ tracc…⁵ ciudad autop…⁶ combu…⁷\n   <chr>     <chr>    <dbl> <int>   <int> <chr>   <chr>    <int>   <int> <chr>  \n 1 audi      a4         1.8  1999       4 auto(l… d           18      29 p      \n 2 audi      a4         1.8  1999       4 manual… d           21      29 p      \n 3 audi      a4         2    2008       4 manual… d           20      31 p      \n 4 audi      a4         2    2008       4 auto(a… d           21      30 p      \n 5 audi      a4         2.8  1999       6 auto(l… d           16      26 p      \n 6 audi      a4         2.8  1999       6 manual… d           18      26 p      \n 7 audi      a4         3.1  2008       6 auto(a… d           18      27 p      \n 8 audi      a4 qu…     1.8  1999       4 manual… 4           18      26 p      \n 9 audi      a4 qu…     1.8  1999       4 auto(l… 4           16      25 p      \n10 audi      a4 qu…     2    2008       4 manual… 4           20      28 p      \n# … with 224 more rows, 1 more variable: clase <chr>, and abbreviated variable\n#   names ¹​fabricante, ²​cilindrada, ³​cilindros, ⁴​transmision, ⁵​traccion,\n#   ⁶​autopista, ⁷​combustible\n\n\nPodemos observar que nos muestra sólo las primeras 10 filas e incluso menciona lo faltante: 224 filas y una columna adicionales. Es solo la visualización, el conjunto se encuentra completo en la memoria de R, por comodidad y practicidad es mejor mostrarlos así. También es posible notar que los nombres de las variables no aparecen completos, pero se especifican en la parte inferior del resultado arrojado.\nDe todas las columnas / variables mostradas, nos interesan la cilindrada (lo cual se refiere al tamaño del motor en litros) y autopista, que muestra la eficiencia del coche en millas recorridas por galón de combustible.\n\nGráfico de dispersión con ggplot\nPara poder mostrar un gráfico con las variables mencionadas anteriormente, debemos introducir el siguiente código:\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista))\n\n\n\n\nEste gráfico muestra una relación negativa entre el tamaño del motor y la eficiencia del combustible. O lo que es lo mismo, a mayor tamaño de motor, menos eficiente el combustible.\nExpliquemos las líneas que ejecutamos para obtener el gráfico. En primer lugar, usamos la función ggplot. El primer argumento de esta función es el conjunto de datos a graficar. Sin embargo, no resulta atractivo el resultado si lo dejamos solo con ese argumento (mostrará un gráfico vacío). Notemos que en segundo lugar, tenemos un signo “+”. Éste nos indica que estamos agregando una capa a ggplot(), la cual es definida por la función geom_point, que no es otra cosa más que una capa de puntos. Esta capa se corresponde con un diagrama de dispersión.\nEl argumento de geom_point() es mapping, el cual define cómo se asignan las variables a la parte visual. Podemos notar que aparece emparejado con la función aes(), la cual determina cuál variable se corresponde con el eje x y cuál al eje y del plano o gráfico. ggplot buscará las variables dentro del conjunto de datos.\nPractiquemos un poco más. Ahora crearemos un gráfico de dispersión autopista contra cilindros.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = autopista, y = cilindros))"
  },
  {
    "objectID": "view.html#mapeos-estéticos",
    "href": "view.html#mapeos-estéticos",
    "title": "Visualización de datos",
    "section": "Mapeos estéticos",
    "text": "Mapeos estéticos\nComencemos a darle mayor personalización a nuestros gráficos. Es probable que deseemos cambiar el color de los puntos de nuestro gráfico de dispersión, basados en algún parámetro. ggplot nos permite cambiar la forma, el color y el tamaño de los puntos, basados en algo llamado parámetro estético. Para diferenciar del uso de la palabra valor en los datos, describiremos los cambios como niveles para los estéticos.\nUtilicemos como criterio estético la variable clase, la cual indica el tipo de vehículo que tenemos en el conjunto de datos. Agreguemos pues esta variable como parte del mapeo (es decir, dentro de la función aes()), sin olvidar que el gráfico de dispersión necesita dos valores numéricos para los ejes, por lo que esta tercera variable también forma parte de los detalles estéticos.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, color = clase))\n\n\n\n\nAsí, hemos conseguido asignar un color único a cada valor de la variable clase. Es más fácil identificar el tipo de coche que hemos graficado. Notemos que ggplot ha agregado una leyenda indicando cuál color corresponde a qué valor.\nSi lo que deseamos utilizar para diferenciar los datos es el tamaño, optaremos por utilizar en los estéticos el argumento size en lugar de color.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, size = clase))\n\nWarning: Using size for a discrete variable is not advised.\n\n\n\n\n\nEl propio R nos hará una advertencia relacionada con el hecho de que utilizar una variable nominal como clase como criterio estético en cuanto a tamaño no resulta ser una buena idea.\nVeamos cómo cambiar la transparencia como parámetro estético:\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, alpha = clase))\n\nWarning: Using alpha for a discrete variable is not advised.\n\n\n\n\n\nAhora, utilizaremos la variable clase para cambiar la forma de los puntos. Cabe mencionar que solo es posible graficar seis formas diferentes a la vez, por lo que si contamos con m[as niveles, estos no se graficarán.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, shape = clase))\n\nWarning: The shape palette can deal with a maximum of 6 discrete values because\nmore than 6 becomes difficult to discriminate; you have 7. Consider\nspecifying shapes manually if you must have them.\n\n\nWarning: Removed 62 rows containing missing values (`geom_point()`).\n\n\n\n\n\nSi en dado caso deseamos utilizar el color para fines meramente estéticos, es decir, sin que aporten información, podemos colorear el gráfico diciéndole a ggplot que cambiaremos el color fuera de la parte estética. Es decir, fuera de aes(). Cambiemos el color de los puntos a rojo:\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista), color = \"red\")\n\n\n\n\nR permite cambiar los puntos en cuanto a color (escribiendo entrecomillado el nombre del color en inglés), tamaño (especificando en mm) y la forma (utilizando uno de los 25 números disponibles, por ejemplo el 0 es un cuadrado, el 1 un círculo y el 2 un triángulo).\n\nFacetas\nPodemos separar los gráficos de acuerdo a variables categóricas. Por ejemplo, es posible que deseemos elaborar un gráfico por cada clase de vehículo. Esto implica una separación con base en una sola variable. Lo realizamos de la siguiente manera:\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista)) +\n  facet_wrap(~clase, nrow = 2)\n\n\n\n\nNotemos que agregamos una capa más a ggplot con el signo ‘+’, en dicha capa escribimos facet_wrap() y dentro suyo una fórmula con variables categóricas. En nuestro caso, la variable clase. El argumento nrow se refiere al número de renglones o filas que queremos tener en la representación de los diferentes gráficos.\nSi por otro lado, deseamos separar los datos con base en dos variables, utilizaremos facet_grid(), la cual admite una fórmula con los nombres de las variables separadas por la virgulilla ~. Veamos cómo hacerlo con las variables traccion y cilindros.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista)) +\n  facet_grid(traccion ~ cilindros)"
  },
  {
    "objectID": "view.html#objetos-geométricos",
    "href": "view.html#objetos-geométricos",
    "title": "Visualización de datos",
    "section": "Objetos geométricos",
    "text": "Objetos geométricos\nEn ggplot se conoce a los tipos de gráficos como geom. Tenemos geom de barra (bar), de línea (line), de línea suavizada (smooth), de caja (boxplot), o de dispersión (point). Cada geom tendrá sus propias opciones de personalización. ggplot cuenta con más de 40 geoms, para referencia sobre ellos podemos acceder a la hoja de referencias disponible en este pdf.\nVeamos algunas de los geoms disponibles.\n\nLínea suavizada\nUtilicemos la gráfica de línea suavizada o geom_smooth() con exactamente los mismos datos que hemos venido utilizando con geom_point().\n\nggplot(data = millas) +\n  geom_smooth(mapping = aes(x = cilindrada, y = autopista))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nPodemos notar que tanto el geom de dispersión como el de línea suavizada son prácticamente lo mismo en cuanto a código, diferenciándose únicamente por el nombre del geom. Sin embargo, hay parámetros estéticos que tienen sentido en uno y no en el otro. Por ejemplo, cabría esperar modificar la forma de los puntos pero no de una línea.\nCambiemos la apariencia de las líneas suavizadas con base en el tipo de transmisión de los vehículos:\n\nggplot(data = millas) +\n  geom_smooth(mapping = aes(x = cilindrada, y = autopista, linetype = traccion))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nNotemos que se realiza la separación en tres tipos: 4 para tracción a 4 ruedas, d para tracción delantera y t para trasera.\n\n\nUso de varios geoms en el mismo gráfico\nBasta con «apilar» las capas en ggplot en una línea por separado.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, color = traccion)) +\n  geom_smooth(mapping = aes(x = cilindrada, y = autopista, color = traccion))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nCabe mencionar que esta simpleza ocasiona el doble trabajo de capturar mapeos a cada geom. Podemos introducir el concepto de mapeos globales y locales en ggplot.\nSi escribimos el mapeo dentro de ggplot() podemos asignar esos valores por defecto a todos los geoms que apilemos, haciendo necesario un solo cambio si deseamos editar la estética de dichos geoms. Veamos el uso del mapeo global:\n\nggplot(data = millas, mapping = aes(x = cilindrada, y = autopista, color = traccion)) +\n  geom_point() +\n  geom_smooth()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nAhora abordemos el uso de los mapeos locales. Estos permiten ampliar o sobrescribir los mapeos globales solo en la capa donde se colocan. Así es posible mostrar diferentes estéticas en cada geom.\n\nggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) +\n  geom_point(mapping = aes(color = clase)) +\n  geom_smooth()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nEn este ejemplo seguiremos teniendo los mismos ejes x y y en ambos geoms, pero solo aplicamos el cambio del color en geom_point().\nVeamos ahora otro ejemplo, pero cambiando el conjunto de datos a mostrar en uno de los geoms. En este caso, grafiquemos solo los coches subcompactos en la línea suavizada utilizando la función filter().\n\nggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) +\n  geom_point(mapping = aes(color = clase)) +\n  geom_smooth(data = filter(millas, clase == \"subcompacto\"), se = FALSE)\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nfilter() filtra los datos que le indicamos, especificando primero el conjunto de datos original y enseguida el criterio de filtrado.\n\n\nGráfico de barras\nVeamos ahora el gráfico de barras. Para ello, usaremos el conjunto de datos diamantes. Agruparemos por la variable corte.\n\nggplot(data = diamantes) +\n  stat_count(mapping = aes(x = corte))\n\n\n\n\nEs importante recordar que el geom_bar() calcula lo que grafica, contrario al gráfico de dispersión que sí toma los valores desde el propio conjunto de datos. Este proceso es conocido como transformación estadística (stat) y cada geom tiene el suyo asociado. En el caso del diagrama de barras, utiliza stat_count(). Esto significa que es posible utilizar indistintivamente el gráfico de barras o el conteo estadístico.\n\nggplot(data = diamantes) +\n  stat_count(mapping = aes(x = corte))\n\n\n\n\n¿Para qué querríamos utilizar la transformación estadística? Hay tres razones:\nEl gráfico de barras genera automáticamente los valores que grafica, por lo que las alturas de las barras no provienen de datos brutos. Es posible que deseemos graficar una variable con valores ya existentes. Por ejemplo, crearemos un subconjunto de datos y crearemos el gráfico a partir de este, cambiando la estadística recuento por identidad para que literalmente tome los valores y no los calcule:\n\nvalores_brutos <- tribble(\n  ~corte, ~freq,\n  \"Regular\", 1610,\n  \"Bueno\", 4906,\n  \"Muy Bueno\", 12082,\n  \"Premium\", 13791,\n  \"Ideal\", 21551\n)\n\nggplot(data = valores_brutos) +\n  geom_bar(mapping = aes(x = corte, y = freq), stat = \"identity\")\n\n\n\n\nNo nos preocupemos ni por tribble() ni por <-. Solo los usamos para crear la tabla que contiene los datos necesarios para el ejemplo, más tarde ahondaremos en ellos.\nPuede ser que deseamos cambiar el mapeo por defecto a uno de proporciones, por ejemplo.\n\nggplot(data = diamantes) +\n  geom_bar(mapping = aes(x = corte, y = stat(prop), group = 1))\n\nWarning: `stat(prop)` was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(prop)` instead.\n\n\n\n\n\nDeseamos resaltar un resumen estadístico de los datos, más allá de solo mostrarlos en un gráfico.\n\nggplot(data = diamantes) +\n  stat_summary(\n    mapping = aes(x = corte, y = profundidad),\n    fun.min = min,\n    fun.max = max,\n    fun = median\n  )\n\n\n\n\nPodemos colorear los gráficos de barras utilizando la estética fill:\n\nggplot(data = diamantes) +\n  geom_bar(mapping = aes(x = corte, fill = corte))"
  },
  {
    "objectID": "view.html#sistemas-de-coordenadas",
    "href": "view.html#sistemas-de-coordenadas",
    "title": "Visualización de datos",
    "section": "Sistemas de coordenadas",
    "text": "Sistemas de coordenadas\nPosiblemente sea la parte más compleja de ggplot. En ocasiones desearemos intercambiar ejes, mejorar el aspecto de ciertos gráficos o utilizar coordenadas polares.\n\nIntercambiar ejes\nVeamos un gráfico de caja como aparece por defecto:\n\nggplot(data = millas, mapping = aes(x = clase, y = autopista)) +\n  geom_boxplot()\n\n\n\n\nAceptemos que no se ve muy bien en cuanto a los títulos de las variables en el eje x. Cambiemos los ejes, para ello se usa coord_flip():\n\nggplot(data = millas, mapping = aes(x = clase, y = autopista)) +\n  geom_boxplot() +\n  coord_flip()"
  }
]