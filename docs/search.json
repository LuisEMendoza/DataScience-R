[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "index",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "index.html#running-code",
    "href": "index.html#running-code",
    "title": "index",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introducción",
    "section": "",
    "text": "Veamos cuáles son los recursos que debemos descargar e instalar primero."
  },
  {
    "objectID": "intro.html#quarto",
    "href": "intro.html#quarto",
    "title": "Introducción",
    "section": "Prerrequisitos",
    "text": "Prerrequisitos\n\nR\nComencemos instalando R. Esto se hace desde el enlace CRAN y eligiendo la plataforma a usar, ya sea Windows, Mac o Linux. En estos apuntes usamos Linux.\n\n\nRStudio\nR es poderoso, pero por defecto funciona con la consola o terminal. Esto puede echarnos para atrás la primera vez. Sin duda, uno se acostumbra y la domina, pero por comodidad podemos comenzar utilizando un buen IDE, en este caso RStudio. Podemos descargarlo e instalarlo desde aquí.\n\n\nTidyverse\nPor sí mismos, R y RStudio son bastante útiles. Sin embargo, es necesario ampliar sus funcionalidades mediante paquetes, que vienen siendo una especie de añadidos que contienen funciones nuevas. En nuestro caso, será el paquete Tidyverse el que instalaremos. Esto es posible lograrlo de dos maneras, siendo la más sencilla la de copiar y pegar la siguiente línea de código en la consola de RStudio:\ninstall.packages(\"tidyverse\")\nDespués de pegar dicha línea en la consola, presionamos Enter para ejecutarla. Así, R descargará e instalará el paquete (es obvio que debemos tener acceso a internet). Es normal que se tome su tiempo.\nJusto después de la instalación, no es posible usar los paquetes por defecto. Debemos cargarlos usando library(), con el nombre del paquete dentro de los paréntesis. Por ejemplo:\nlibrary(tidyverse)\nDebe aparecer un mensaje que mencione varios nombres, como ggplot2, purr o tibble. Eso significa que se ha cargado correctamente.\nEs importante que no descuidemos la actualidad de estos paquetes. Podemos actualizarlos después de haber cargado el paquete mediante\ntidyverse_update()\nLo cual buscará versiones más recientes y, de haberlas, nos dará unas líneas de código que nos permitirá obtenerlas.\n\n\nPaquete datos\nEn estos apuntes se utilizan datos recuperados de varios cursos. Uno muy importante es precisamente el libro Ciencia de Datos con R, cuyo conjunto de datos se llama, precisamente datos. Desde R es posible instalarlos con\ninstall.packages(\"datos\")"
  },
  {
    "objectID": "intro.html#ejecutando-código",
    "href": "intro.html#ejecutando-código",
    "title": "Introducción",
    "section": "Ejecutando código",
    "text": "Ejecutando código\nSe recomienda que el código que vayamos mostrando se vaya introduciendo y ejecutando en la consola de RStudio. La ventaja de que estos apuntes sean electrónicos es que podemos mostrar el código tal cual pueda ser copiado y pegado en dicha consola. De hecho, hay hasta un botón que permite copiarlo. Identificaremos el código «copiable» porque estará escrito como a continuación:\n1 + 2 \nLocaliza el botón de copiar y presiónalo. Ahora pégalo en tu consola de RStudio. Debes comprobar que te arroja lo siguiente, exactamente como te lo mostramos:\n\n\n[1] 3\n\n\nCabe mencionar que retomamos algunas convenciones del libro ya citado arriba. Entre ellas, se encuentran:\n\nLos nombres de funciones estarán escritos en fuente para código y con un par de paréntesis vacíos enseguida sum();\nLos nombres de datos, de argumentos o de variables irán con la misma fuente, pero sin paréntesis datos, y por último\nSi un objeto viene de un paquete y debemos especificar ambos, vendrá el nombre del paquete, enseguida doble dos puntos y al final el nombre del objeto, por ejemplo dplyr::mutate."
  },
  {
    "objectID": "view.html",
    "href": "view.html",
    "title": "Visualización de datos",
    "section": "",
    "text": "Aunque parezca lo más práctico comenzar con la organización y transformación de los datos, comenzaremos por el otro lado. Veamos primero cómo crear gráficos coherentes y hasta elegantes.\nUtilizaremos el paquete ggplot, que utiliza un sistema conocido como la gramática de gráficos. Carguemos dicho paquete, además del conjunto de datos a utilizar:\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.0     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.1     ✔ tibble    3.2.0\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the \u001b]8;;http://conflicted.r-lib.org/\u0007conflicted package\u001b]8;;\u0007 to force all conflicts to become errors\n\nlibrary(datos)"
  },
  {
    "objectID": "view.html#nuestro-primer-gráfico",
    "href": "view.html#nuestro-primer-gráfico",
    "title": "Visualización de datos",
    "section": "Nuestro primer gráfico",
    "text": "Nuestro primer gráfico\nCrearemos nuestro primer gráfico con ggplot y probaremos con datos reales que a mayor tamaño de motor de un coche, mayor consumo de gasolina tendrá. Para ello, debemos estar seguros de haber cargado correctamente tanto el Tydiverse como el conjunto datos. Enseguida mostraremos un data frame, lo cual es un conjunto rectangular de datos organizados en columnas (que vienen siendo las variables) y filas (éstas son las observaciones). Este data frame es llamado millas, el cual está contenido en datos (datos::millas).\n\nmillas\n\n# A tibble: 234 × 11\n   fabrica…¹ modelo cilin…²  anio cilin…³ trans…⁴ tracc…⁵ ciudad autop…⁶ combu…⁷\n   <chr>     <chr>    <dbl> <int>   <int> <chr>   <chr>    <int>   <int> <chr>  \n 1 audi      a4         1.8  1999       4 auto(l… d           18      29 p      \n 2 audi      a4         1.8  1999       4 manual… d           21      29 p      \n 3 audi      a4         2    2008       4 manual… d           20      31 p      \n 4 audi      a4         2    2008       4 auto(a… d           21      30 p      \n 5 audi      a4         2.8  1999       6 auto(l… d           16      26 p      \n 6 audi      a4         2.8  1999       6 manual… d           18      26 p      \n 7 audi      a4         3.1  2008       6 auto(a… d           18      27 p      \n 8 audi      a4 qu…     1.8  1999       4 manual… 4           18      26 p      \n 9 audi      a4 qu…     1.8  1999       4 auto(l… 4           16      25 p      \n10 audi      a4 qu…     2    2008       4 manual… 4           20      28 p      \n# … with 224 more rows, 1 more variable: clase <chr>, and abbreviated variable\n#   names ¹​fabricante, ²​cilindrada, ³​cilindros, ⁴​transmision, ⁵​traccion,\n#   ⁶​autopista, ⁷​combustible\n\n\nPodemos observar que nos muestra sólo las primeras 10 filas e incluso menciona lo faltante: 224 filas y una columna adicionales. Es solo la visualización, el conjunto se encuentra completo en la memoria de R, por comodidad y practicidad es mejor mostrarlos así. También es posible notar que los nombres de las variables no aparecen completos, pero se especifican en la parte inferior del resultado arrojado.\nDe todas las columnas / variables mostradas, nos interesan la cilindrada (lo cual se refiere al tamaño del motor en litros) y autopista, que muestra la eficiencia del coche en millas recorridas por galón de combustible.\n\nGráfico de dispersión con ggplot\nPara poder mostrar un gráfico con las variables mencionadas anteriormente, debemos introducir el siguiente código:\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista))\n\n\n\n\nEste gráfico muestra una relación negativa entre el tamaño del motor y la eficiencia del combustible. O lo que es lo mismo, a mayor tamaño de motor, menos eficiente el combustible.\nExpliquemos las líneas que ejecutamos para obtener el gráfico. En primer lugar, usamos la función ggplot. El primer argumento de esta función es el conjunto de datos a graficar. Sin embargo, no resulta atractivo el resultado si lo dejamos solo con ese argumento (mostrará un gráfico vacío). Notemos que en segundo lugar, tenemos un signo “+”. Éste nos indica que estamos agregando una capa a ggplot(), la cual es definida por la función geom_point, que no es otra cosa más que una capa de puntos. Esta capa se corresponde con un diagrama de dispersión.\nEl argumento de geom_point() es mapping, el cual define cómo se asignan las variables a la parte visual. Podemos notar que aparece emparejado con la función aes(), la cual determina cuál variable se corresponde con el eje x y cuál al eje y del plano o gráfico. ggplot buscará las variables dentro del conjunto de datos.\nPractiquemos un poco más. Ahora crearemos un gráfico de dispersión autopista contra cilindros.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = autopista, y = cilindros))"
  },
  {
    "objectID": "view.html#mapeos-estéticos",
    "href": "view.html#mapeos-estéticos",
    "title": "Visualización de datos",
    "section": "Mapeos estéticos",
    "text": "Mapeos estéticos\nComencemos a darle mayor personalización a nuestros gráficos. Es probable que deseemos cambiar el color de los puntos de nuestro gráfico de dispersión, basados en algún parámetro. ggplot nos permite cambiar la forma, el color y el tamaño de los puntos, basados en algo llamado parámetro estético. Para diferenciar del uso de la palabra valor en los datos, describiremos los cambios como niveles para los estéticos.\nUtilicemos como criterio estético la variable clase, la cual indica el tipo de vehículo que tenemos en el conjunto de datos. Agreguemos pues esta variable como parte del mapeo (es decir, dentro de la función aes()), sin olvidar que el gráfico de dispersión necesita dos valores numéricos para los ejes, por lo que esta tercera variable también forma parte de los detalles estéticos.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, color = clase))\n\n\n\n\nAsí, hemos conseguido asignar un color único a cada valor de la variable clase. Es más fácil identificar el tipo de coche que hemos graficado. Notemos que ggplot ha agregado una leyenda indicando cuál color corresponde a qué valor.\nSi lo que deseamos utilizar para diferenciar los datos es el tamaño, optaremos por utilizar en los estéticos el argumento size en lugar de color.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, size = clase))\n\nWarning: Using size for a discrete variable is not advised.\n\n\n\n\n\nEl propio R nos hará una advertencia relacionada con el hecho de que utilizar una variable nominal como clase como criterio estético en cuanto a tamaño no resulta ser una buena idea.\nVeamos cómo cambiar la transparencia como parámetro estético:\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, alpha = clase))\n\nWarning: Using alpha for a discrete variable is not advised.\n\n\n\n\n\nAhora, utilizaremos la variable clase para cambiar la forma de los puntos. Cabe mencionar que solo es posible graficar seis formas diferentes a la vez, por lo que si contamos con m[as niveles, estos no se graficarán.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, shape = clase))\n\nWarning: The shape palette can deal with a maximum of 6 discrete values because\nmore than 6 becomes difficult to discriminate; you have 7. Consider\nspecifying shapes manually if you must have them.\n\n\nWarning: Removed 62 rows containing missing values (`geom_point()`).\n\n\n\n\n\nSi en dado caso deseamos utilizar el color para fines meramente estéticos, es decir, sin que aporten información, podemos colorear el gráfico diciéndole a ggplot que cambiaremos el color fuera de la parte estética. Es decir, fuera de aes(). Cambiemos el color de los puntos a rojo:\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista), color = \"red\")\n\n\n\n\nR permite cambiar los puntos en cuanto a color (escribiendo entrecomillado el nombre del color en inglés), tamaño (especificando en mm) y la forma (utilizando uno de los 25 números disponibles, por ejemplo el 0 es un cuadrado, el 1 un círculo y el 2 un triángulo).\n\nFacetas\nPodemos separar los gráficos de acuerdo a variables categóricas. Por ejemplo, es posible que deseemos elaborar un gráfico por cada clase de vehículo. Esto implica una separación con base en una sola variable. Lo realizamos de la siguiente manera:\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista)) +\n  facet_wrap(~clase, nrow = 2)\n\n\n\n\nNotemos que agregamos una capa más a ggplot con el signo ‘+’, en dicha capa escribimos facet_wrap() y dentro suyo una fórmula con variables categóricas. En nuestro caso, la variable clase. El argumento nrow se refiere al número de renglones o filas que queremos tener en la representación de los diferentes gráficos.\nSi por otro lado, deseamos separar los datos con base en dos variables, utilizaremos facet_grid(), la cual admite una fórmula con los nombres de las variables separadas por la virgulilla ~. Veamos cómo hacerlo con las variables traccion y cilindros.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista)) +\n  facet_grid(traccion ~ cilindros)"
  },
  {
    "objectID": "view.html#objetos-geométricos",
    "href": "view.html#objetos-geométricos",
    "title": "Visualización de datos",
    "section": "Objetos geométricos",
    "text": "Objetos geométricos\nEn ggplot se conoce a los tipos de gráficos como geom. Tenemos geom de barra (bar), de línea (line), de línea suavizada (smooth), de caja (boxplot), o de dispersión (point). Cada geom tendrá sus propias opciones de personalización. ggplot cuenta con más de 40 geoms, para referencia sobre ellos podemos acceder a la hoja de referencias disponible en este pdf.\nVeamos algunas de los geoms disponibles.\n\nLínea suavizada\nUtilicemos la gráfica de línea suavizada o geom_smooth() con exactamente los mismos datos que hemos venido utilizando con geom_point().\n\nggplot(data = millas) +\n  geom_smooth(mapping = aes(x = cilindrada, y = autopista))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nPodemos notar que tanto el geom de dispersión como el de línea suavizada son prácticamente lo mismo en cuanto a código, diferenciándose únicamente por el nombre del geom. Sin embargo, hay parámetros estéticos que tienen sentido en uno y no en el otro. Por ejemplo, cabría esperar modificar la forma de los puntos pero no de una línea.\nCambiemos la apariencia de las líneas suavizadas con base en el tipo de transmisión de los vehículos:\n\nggplot(data = millas) +\n  geom_smooth(mapping = aes(x = cilindrada, y = autopista, linetype = traccion))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nNotemos que se realiza la separación en tres tipos: 4 para tracción a 4 ruedas, d para tracción delantera y t para trasera.\n\n\nUso de varios geoms en el mismo gráfico\nBasta con «apilar» las capas en ggplot en una línea por separado.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, color = traccion)) +\n  geom_smooth(mapping = aes(x = cilindrada, y = autopista, color = traccion))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nCabe mencionar que esta simpleza ocasiona el doble trabajo de capturar mapeos a cada geom. Podemos introducir el concepto de mapeos globales y locales en ggplot.\nSi escribimos el mapeo dentro de ggplot() podemos asignar esos valores por defecto a todos los geoms que apilemos, haciendo necesario un solo cambio si deseamos editar la estética de dichos geoms. Veamos el uso del mapeo global:\n\nggplot(data = millas, mapping = aes(x = cilindrada, y = autopista, color = traccion)) +\n  geom_point() +\n  geom_smooth()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nAhora abordemos el uso de los mapeos locales. Estos permiten ampliar o sobrescribir los mapeos globales solo en la capa donde se colocan. Así es posible mostrar diferentes estéticas en cada geom.\n\nggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) +\n  geom_point(mapping = aes(color = clase)) +\n  geom_smooth()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nEn este ejemplo seguiremos teniendo los mismos ejes x y y en ambos geoms, pero solo aplicamos el cambio del color en geom_point().\nVeamos ahora otro ejemplo, pero cambiando el conjunto de datos a mostrar en uno de los geoms. En este caso, grafiquemos solo los coches subcompactos en la línea suavizada utilizando la función filter().\n\nggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) +\n  geom_point(mapping = aes(color = clase)) +\n  geom_smooth(data = filter(millas, clase == \"subcompacto\"), se = FALSE)\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nfilter() filtra los datos que le indicamos, especificando primero el conjunto de datos original y enseguida el criterio de filtrado.\n\n\nGráfico de barras\nVeamos ahora el gráfico de barras. Para ello, usaremos el conjunto de datos diamantes. Agruparemos por la variable corte.\n\nggplot(data = diamantes) +\n  stat_count(mapping = aes(x = corte))\n\n\n\n\nEs importante recordar que el geom_bar() calcula lo que grafica, contrario al gráfico de dispersión que sí toma los valores desde el propio conjunto de datos. Este proceso es conocido como transformación estadística (stat) y cada geom tiene el suyo asociado. En el caso del diagrama de barras, utiliza stat_count(). Esto significa que es posible utilizar indistintivamente el gráfico de barras o el conteo estadístico.\n\nggplot(data = diamantes) +\n  stat_count(mapping = aes(x = corte))\n\n\n\n\n¿Para qué querríamos utilizar la transformación estadística? Hay tres razones:\nEl gráfico de barras genera automáticamente los valores que grafica, por lo que las alturas de las barras no provienen de datos brutos. Es posible que deseemos graficar una variable con valores ya existentes. Por ejemplo, crearemos un subconjunto de datos y crearemos el gráfico a partir de este, cambiando la estadística recuento por identidad para que literalmente tome los valores y no los calcule:\n\nvalores_brutos <- tribble(\n  ~corte, ~freq,\n  \"Regular\", 1610,\n  \"Bueno\", 4906,\n  \"Muy Bueno\", 12082,\n  \"Premium\", 13791,\n  \"Ideal\", 21551\n)\n\nggplot(data = valores_brutos) +\n  geom_bar(mapping = aes(x = corte, y = freq), stat = \"identity\")\n\n\n\n\nNo nos preocupemos ni por tribble() ni por <-. Solo los usamos para crear la tabla que contiene los datos necesarios para el ejemplo, más tarde ahondaremos en ellos.\nPuede ser que deseamos cambiar el mapeo por defecto a uno de proporciones, por ejemplo.\n\nggplot(data = diamantes) +\n  geom_bar(mapping = aes(x = corte, y = stat(prop), group = 1))\n\nWarning: `stat(prop)` was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(prop)` instead.\n\n\n\n\n\nDeseamos resaltar un resumen estadístico de los datos, más allá de solo mostrarlos en un gráfico.\n\nggplot(data = diamantes) +\n  stat_summary(\n    mapping = aes(x = corte, y = profundidad),\n    fun.min = min,\n    fun.max = max,\n    fun = median\n  )\n\n\n\n\nPodemos colorear los gráficos de barras utilizando la estética fill:\n\nggplot(data = diamantes) +\n  geom_bar(mapping = aes(x = corte, fill = corte))"
  },
  {
    "objectID": "view.html#sistemas-de-coordenadas",
    "href": "view.html#sistemas-de-coordenadas",
    "title": "Visualización de datos",
    "section": "Sistemas de coordenadas",
    "text": "Sistemas de coordenadas\nPosiblemente sea la parte más compleja de ggplot. En ocasiones desearemos intercambiar ejes, mejorar el aspecto de ciertos gráficos o utilizar coordenadas polares.\n\nIntercambiar ejes\nVeamos un gráfico de caja como aparece por defecto:\n\nggplot(data = millas, mapping = aes(x = clase, y = autopista)) +\n  geom_boxplot()\n\n\n\n\nCambiemos los ejes, para ello se usa coord_flip():\n\nggplot(data = millas, mapping = aes(x = clase, y = autopista)) +\n  geom_boxplot() +\n  coord_flip()\n\n\n\n\n\n\nAjuste de mapas\nPor si en algún momento debemos graficar mapas, es posible que no salgan bien representados.\n\nlibrary(maps)\n\n\nAttaching package: 'maps'\n\n\nThe following object is masked from 'package:purrr':\n\n    map\n\nnz <- map_data(\"nz\")\n\nggplot(nz, aes(long, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\")\n\n\n\n\nPodemos arreglar sus proporciones de la siguiente manera:\n\nggplot(nz, aes(long, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\") +\n  coord_quickmap()\n\n\n\n\n\n\nCoordenadas polares\nPodemos intercambiar las coordenadas cartesianas a polares, usando el siguiente código que muestra la relación entre dos tipos de gráfico:\n\nbar <- ggplot(data = diamantes) +\n  geom_bar(\n    mapping = aes(x = corte, fill = corte),\n    show.legend = FALSE,\n    width = 1\n  ) +\n  theme(aspect.ratio = 1) +\n  labs(x = NULL, y = NULL)\n\nbar + coord_flip()\n\n\n\nbar + coord_polar()"
  },
  {
    "objectID": "DC_view.html",
    "href": "DC_view.html",
    "title": "Visualización de datos - DC",
    "section": "",
    "text": "Para tener un primer acercamiento sobre la visualización de datos con R, demos un acercamiento a ggplot. Carguemos el paquete con\n\nlibrary(ggplot2)\n\ny procedamos a explorar un conjunto de datos ya presente en R: mtcars. Este conjunto de datos es pequeño y muy ilustrativo. Lo examinaremos con la función str().\n\nstr(mtcars)\n\n'data.frame':   32 obs. of  11 variables:\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num  160 160 108 258 360 ...\n $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num  16.5 17 18.6 19.4 17 ...\n $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n\n\nAhora que conocemos un poco de la estructura de mtcars, obtengamos de él un gráfico de dispersión utilizando ggplot() con cyl como la variable x y mpg como la variable y.\n\nggplot(data = mtcars, mapping = aes(x = cyl, y = mpg)) + \n  geom_point()\n\n\n\n\nEl gráfico resultante no es del todo adecuado, ya que muestra espacios vacíos en el eje x, pero como acercamiento es correcto. Si queremos mejorarlo, debemos convertir la variable cyl en una variable categórica, ya que es tratada como numérica por ggplot. Esto lo conseguimos con el siguiente comando:\n\nggplot(data = mtcars, mapping = aes(x = factor(cyl), y = mpg)) +\n  geom_point()\n\n\n\n\nPodemos notar que ahora ya solo se muestran valores existentes en el conjunto de datos.\n\n\n\nObservemos detenidamente la estructura del comando anterior. ggplot sigue algo conocido como la gramática de gráficos. Ésta consiste de tres elementos básicos: los datos o variables de interés, las escalas en las que mapearemos dichos datos (las estéticas) y los elementos visuales usados para nuestros datos (las geometrías). De manera opcional, entra una cuarta capa, los temas.\nEntre las Estéticas podemos encontrar los ejes x y y, el color de contorno o relleno de las formas, el tamaño, las etiquetas, transparencias, el tipo de forma, la anchura o el tipo de línea dibujada.\nPara el caso de las Geometrías (que en delante llamaremos geom) se pueden contar los tipos de gráfico: línea (line), puntos (points), histograma (histogram), caja (boxplot) o barras (bar).\nEntremos un poco más en estos tres conceptos: datos, estéticas y geoms. Agreguemos color a nuestro gráfico, utilizando una de las variables de los datos. El argumento color debe colocarse dentro de aes().\n\nggplot(data = mtcars, mapping = aes(x = wt, y = mpg, color = disp)) +\n  geom_point()\n\n\n\n\nEnseguida haremos que el tamaño de las formas depende precisamente de la variable ya usada, disp.\n\nggplot(data = mtcars, mapping = aes(x = wt, y = mpg, size = disp)) +\n  geom_point()\n\n\n\n\nSin embargo, hay que tener cuidado con el hecho de que una variable continua no debe ser mapeada con shape. Por ende, shape no existe en una escala continua.\n\n\nLa gramática de gráficos utiliza el concepto de capas para la construcción de gráficos. La capa más inferior es la que se corresponde con los datos.\nPara esta sección se trabajará con el ya clásico conjunto de datos llamado iris, que recoge información de tres especies de lirios: setosa, versicolor y virginica. Fueron tomadas cuatro mediciones de cada planta: tanto la longitud y anchura de pétalos como las de los sépalos. Los pétalos se identifican usualmente como la parte colorida de las flores, mientras que los sépalos son las hojas externas de color verde de las mismas flores, aunque cabe mencionar que en el caso de los lirios, los sépalos son coloridos también. El conjunto de datos iris contiene cinco variables: el nombre de especie y las cuatro mediciones mencionadas antes.\n\n\n\nEsta capa nos indica cuál es la escala y la manera en la que mapearemos nuestros datos, es decir, definiremos el tipo de gráfico y sus ejes, por lo que de manera indirecta también quedará determinado el rango de visión de nuestros datos.\nContinuando con el ejemplo del conjunto iris, crearemos un gráfico de dispersión cuyos ejes x y y serán asociados con la longitud y la anchura de los sépalos, respectivamente.\n\n\n\nEste último elemento nos permite elegir cómo se verá el gráfico. Resulta algo contradictorio que la capa estética se encargue de lo geométrico y la capa geometría de lo visual. Pero así trabaja ggplot.\nCon la información provista por las tres capas, es posible crear ya un gráfico simple, quizá algo rústico, pero funcional.\n\n\n\nSi deseamos darle mayor claridad o facilidad de interpretación a nuestro gráfico, echaremos mano de una capa opcional: tema.\n\n\n\n\nTrabajemos con el set de datos conocido como diamonds, que incluye información sobre diamantes. Exploremos su contenido\n\nstr(diamonds)\n\ntibble [53,940 × 10] (S3: tbl_df/tbl/data.frame)\n $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...\n $ cut    : Ord.factor w/ 5 levels \"Fair\"<\"Good\"<..: 5 4 2 4 2 3 3 3 1 3 ...\n $ color  : Ord.factor w/ 7 levels \"D\"<\"E\"<\"F\"<\"G\"<..: 2 2 2 6 7 7 6 5 2 5 ...\n $ clarity: Ord.factor w/ 8 levels \"I1\"<\"SI2\"<\"SI1\"<..: 2 3 5 4 2 6 7 3 4 5 ...\n $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...\n $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...\n $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...\n $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...\n $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...\n $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...\n\n\nPodemos notar que cuenta con varias variables, de las cuales nos interesan carat (una medida del tamaño de los diamantes) y price (se corresponde con el precio).\nVamos a crear un gráfico de dispersión que relacione estas variables. Queremos dejar el precio como la variable dependiente, así que ejecutemos los siguientes comandos:\n\nggplot(data = diamonds, mapping = aes(x = carat, y = price)) +\n  geom_point()\n\n\n\n\nAhora queremos agregar una línea de tendencia suavizada a nuestro gráfico. Simplemente añadimos una capa de geometría más utilizando la misma lógica, con geom_smooth():\n\nggplot(data = diamonds, mapping = aes(x = carat, y = price)) +\n  geom_point() +\n  geom_smooth()\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\n\n\n\nEs posible modificar los mapeos de manera general o que afecten a geometrías específicas. Si deseamos hacerlo globalmente, la modificación la realizaremos en la línea correspondiente a ggplot. En caso contrario modificamos la línea correspondiente a la geometría en sí. Cambiemos el color de ambas geometrías utilizando la variable incluida en el set de datos llamada clarity asignada al argumento color de ggplot:\n\nggplot(data = diamonds, mapping = aes(x = carat, y = price, color = clarity)) +\n  geom_point() +\n  geom_smooth()\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\nLa geometría geom_point() cuenta con un argumento llamado alpha que controla la opacidad de los puntos mostrados, cuyos valores van de 0 a 1. Un valor de 1 implica toyal opacidad y uno de 0 la transparencia máxima: invisibilidad. Dibujemos los puntos un 40% más transparentes para facilitar su lectura, modificando el mapeo únicamente para la geometría de dispersión.\n\nggplot(data = diamonds, mapping = aes(x = carat, y = price, color = clarity)) +\n  geom_point(aes(alpha = 0.4)) +\n  geom_smooth()\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\n\n\n\nEs posible almacenar los plots como variables, utilizando la asignación común en R. Sin embargo, es usual que se asigne solo las capas datos y estética, dejando las geometrías para después.\nCreemos la variable plot_price_vs_carat y asignemos el gráfico a la misma\n\nplot_price_vs_carat <- ggplot(data = diamonds, mapping = aes(x = carat, y = price))\n\nEl comando anterior crea el gráfico pero no lo muestra pues falta la geometría. La agregamos y mostramos con\n\nplot_price_vs_carat + geom_point()\n\n\n\n\nLa utilidad de trabajar con los gráficos almacenados en variables es que nos permite crear y modificar de manera libre, ya que siempre podemos recuperar el original llamando a la variable. Vamos a crear otro gráfico con transparencias al 20%, asignando el original a otra variable y modificando ésta con aes().\n\ntrans_plot <- plot_price_vs_carat + geom_point(aes(alpha = 0.2))\n\nPara visualizar nuestro gráfico basta con llamar la variable:\n\ntrans_plot\n\n\n\n\nTambién podemos hacer lo mismo con el color y otra variable.\n\nbyclarity_plot <- plot_price_vs_carat + geom_point(aes(color = clarity))\nbyclarity_plot"
  },
  {
    "objectID": "R4DS_view.html",
    "href": "R4DS_view.html",
    "title": "Visualización de datos - R4DS",
    "section": "",
    "text": "Aunque parezca lo más práctico comenzar con la organización y transformación de los datos, comenzaremos por el otro lado. Veamos primero cómo crear gráficos coherentes y hasta elegantes.\nUtilizaremos el paquete ggplot, que utiliza un sistema conocido como la gramática de gráficos. Carguemos dicho paquete, además del conjunto de datos a utilizar:\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.0     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.1     ✔ tibble    3.2.0\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the \u001b]8;;http://conflicted.r-lib.org/\u0007conflicted package\u001b]8;;\u0007 to force all conflicts to become errors\n\nlibrary(datos)"
  },
  {
    "objectID": "R4DS_view.html#nuestro-primer-gráfico",
    "href": "R4DS_view.html#nuestro-primer-gráfico",
    "title": "Visualización de datos - R4DS",
    "section": "Nuestro primer gráfico",
    "text": "Nuestro primer gráfico\nCrearemos nuestro primer gráfico con ggplot y probaremos con datos reales que a mayor tamaño de motor de un coche, mayor consumo de gasolina tendrá. Para ello, debemos estar seguros de haber cargado correctamente tanto el Tydiverse como el conjunto datos. Enseguida mostraremos un data frame, lo cual es un conjunto rectangular de datos organizados en columnas (que vienen siendo las variables) y filas (éstas son las observaciones). Este data frame es llamado millas, el cual está contenido en datos (datos::millas).\n\nmillas\n\n# A tibble: 234 × 11\n   fabrica…¹ modelo cilin…²  anio cilin…³ trans…⁴ tracc…⁵ ciudad autop…⁶ combu…⁷\n   <chr>     <chr>    <dbl> <int>   <int> <chr>   <chr>    <int>   <int> <chr>  \n 1 audi      a4         1.8  1999       4 auto(l… d           18      29 p      \n 2 audi      a4         1.8  1999       4 manual… d           21      29 p      \n 3 audi      a4         2    2008       4 manual… d           20      31 p      \n 4 audi      a4         2    2008       4 auto(a… d           21      30 p      \n 5 audi      a4         2.8  1999       6 auto(l… d           16      26 p      \n 6 audi      a4         2.8  1999       6 manual… d           18      26 p      \n 7 audi      a4         3.1  2008       6 auto(a… d           18      27 p      \n 8 audi      a4 qu…     1.8  1999       4 manual… 4           18      26 p      \n 9 audi      a4 qu…     1.8  1999       4 auto(l… 4           16      25 p      \n10 audi      a4 qu…     2    2008       4 manual… 4           20      28 p      \n# … with 224 more rows, 1 more variable: clase <chr>, and abbreviated variable\n#   names ¹​fabricante, ²​cilindrada, ³​cilindros, ⁴​transmision, ⁵​traccion,\n#   ⁶​autopista, ⁷​combustible\n\n\nPodemos observar que nos muestra sólo las primeras 10 filas e incluso menciona lo faltante: 224 filas y una columna adicionales. Es solo la visualización, el conjunto se encuentra completo en la memoria de R, por comodidad y practicidad es mejor mostrarlos así. También es posible notar que los nombres de las variables no aparecen completos, pero se especifican en la parte inferior del resultado arrojado.\nDe todas las columnas / variables mostradas, nos interesan la cilindrada (lo cual se refiere al tamaño del motor en litros) y autopista, que muestra la eficiencia del coche en millas recorridas por galón de combustible.\n\nGráfico de dispersión con ggplot\nPara poder mostrar un gráfico con las variables mencionadas anteriormente, debemos introducir el siguiente código:\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista))\n\n\n\n\nEste gráfico muestra una relación negativa entre el tamaño del motor y la eficiencia del combustible. O lo que es lo mismo, a mayor tamaño de motor, menos eficiente el combustible.\nExpliquemos las líneas que ejecutamos para obtener el gráfico. En primer lugar, usamos la función ggplot. El primer argumento de esta función es el conjunto de datos a graficar. Sin embargo, no resulta atractivo el resultado si lo dejamos solo con ese argumento (mostrará un gráfico vacío). Notemos que en segundo lugar, tenemos un signo “+”. Éste nos indica que estamos agregando una capa a ggplot(), la cual es definida por la función geom_point, que no es otra cosa más que una capa de puntos. Esta capa se corresponde con un diagrama de dispersión.\nEl argumento de geom_point() es mapping, el cual define cómo se asignan las variables a la parte visual. Podemos notar que aparece emparejado con la función aes(), la cual determina cuál variable se corresponde con el eje x y cuál al eje y del plano o gráfico. ggplot buscará las variables dentro del conjunto de datos.\nPractiquemos un poco más. Ahora crearemos un gráfico de dispersión autopista contra cilindros.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = autopista, y = cilindros))"
  },
  {
    "objectID": "R4DS_view.html#mapeos-estéticos",
    "href": "R4DS_view.html#mapeos-estéticos",
    "title": "Visualización de datos - R4DS",
    "section": "Mapeos estéticos",
    "text": "Mapeos estéticos\nComencemos a darle mayor personalización a nuestros gráficos. Es probable que deseemos cambiar el color de los puntos de nuestro gráfico de dispersión, basados en algún parámetro. ggplot nos permite cambiar la forma, el color y el tamaño de los puntos, basados en algo llamado parámetro estético. Para diferenciar del uso de la palabra valor en los datos, describiremos los cambios como niveles para los estéticos.\nUtilicemos como criterio estético la variable clase, la cual indica el tipo de vehículo que tenemos en el conjunto de datos. Agreguemos pues esta variable como parte del mapeo (es decir, dentro de la función aes()), sin olvidar que el gráfico de dispersión necesita dos valores numéricos para los ejes, por lo que esta tercera variable también forma parte de los detalles estéticos.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, color = clase))\n\n\n\n\nAsí, hemos conseguido asignar un color único a cada valor de la variable clase. Es más fácil identificar el tipo de coche que hemos graficado. Notemos que ggplot ha agregado una leyenda indicando cuál color corresponde a qué valor.\nSi lo que deseamos utilizar para diferenciar los datos es el tamaño, optaremos por utilizar en los estéticos el argumento size en lugar de color.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, size = clase))\n\nWarning: Using size for a discrete variable is not advised.\n\n\n\n\n\nEl propio R nos hará una advertencia relacionada con el hecho de que utilizar una variable nominal como clase como criterio estético en cuanto a tamaño no resulta ser una buena idea.\nVeamos cómo cambiar la transparencia como parámetro estético:\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, alpha = clase))\n\nWarning: Using alpha for a discrete variable is not advised.\n\n\n\n\n\nAhora, utilizaremos la variable clase para cambiar la forma de los puntos. Cabe mencionar que solo es posible graficar seis formas diferentes a la vez, por lo que si contamos con m[as niveles, estos no se graficarán.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, shape = clase))\n\nWarning: The shape palette can deal with a maximum of 6 discrete values because\nmore than 6 becomes difficult to discriminate; you have 7. Consider\nspecifying shapes manually if you must have them.\n\n\nWarning: Removed 62 rows containing missing values (`geom_point()`).\n\n\n\n\n\nSi en dado caso deseamos utilizar el color para fines meramente estéticos, es decir, sin que aporten información, podemos colorear el gráfico diciéndole a ggplot que cambiaremos el color fuera de la parte estética. Es decir, fuera de aes(). Cambiemos el color de los puntos a rojo:\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista), color = \"red\")\n\n\n\n\nR permite cambiar los puntos en cuanto a color (escribiendo entrecomillado el nombre del color en inglés), tamaño (especificando en mm) y la forma (utilizando uno de los 25 números disponibles, por ejemplo el 0 es un cuadrado, el 1 un círculo y el 2 un triángulo).\n\nFacetas\nPodemos separar los gráficos de acuerdo a variables categóricas. Por ejemplo, es posible que deseemos elaborar un gráfico por cada clase de vehículo. Esto implica una separación con base en una sola variable. Lo realizamos de la siguiente manera:\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista)) +\n  facet_wrap(~clase, nrow = 2)\n\n\n\n\nNotemos que agregamos una capa más a ggplot con el signo ‘+’, en dicha capa escribimos facet_wrap() y dentro suyo una fórmula con variables categóricas. En nuestro caso, la variable clase. El argumento nrow se refiere al número de renglones o filas que queremos tener en la representación de los diferentes gráficos.\nSi por otro lado, deseamos separar los datos con base en dos variables, utilizaremos facet_grid(), la cual admite una fórmula con los nombres de las variables separadas por la virgulilla ~. Veamos cómo hacerlo con las variables traccion y cilindros.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista)) +\n  facet_grid(traccion ~ cilindros)"
  },
  {
    "objectID": "R4DS_view.html#objetos-geométricos",
    "href": "R4DS_view.html#objetos-geométricos",
    "title": "Visualización de datos - R4DS",
    "section": "Objetos geométricos",
    "text": "Objetos geométricos\nEn ggplot se conoce a los tipos de gráficos como geom. Tenemos geom de barra (bar), de línea (line), de línea suavizada (smooth), de caja (boxplot), o de dispersión (point). Cada geom tendrá sus propias opciones de personalización. ggplot cuenta con más de 40 geoms, para referencia sobre ellos podemos acceder a la hoja de referencias disponible en este pdf.\nVeamos algunas de los geoms disponibles.\n\nLínea suavizada\nUtilicemos la gráfica de línea suavizada o geom_smooth() con exactamente los mismos datos que hemos venido utilizando con geom_point().\n\nggplot(data = millas) +\n  geom_smooth(mapping = aes(x = cilindrada, y = autopista))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nPodemos notar que tanto el geom de dispersión como el de línea suavizada son prácticamente lo mismo en cuanto a código, diferenciándose únicamente por el nombre del geom. Sin embargo, hay parámetros estéticos que tienen sentido en uno y no en el otro. Por ejemplo, cabría esperar modificar la forma de los puntos pero no de una línea.\nCambiemos la apariencia de las líneas suavizadas con base en el tipo de transmisión de los vehículos:\n\nggplot(data = millas) +\n  geom_smooth(mapping = aes(x = cilindrada, y = autopista, linetype = traccion))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nNotemos que se realiza la separación en tres tipos: 4 para tracción a 4 ruedas, d para tracción delantera y t para trasera.\n\n\nUso de varios geoms en el mismo gráfico\nBasta con «apilar» las capas en ggplot en una línea por separado.\n\nggplot(data = millas) +\n  geom_point(mapping = aes(x = cilindrada, y = autopista, color = traccion)) +\n  geom_smooth(mapping = aes(x = cilindrada, y = autopista, color = traccion))\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nCabe mencionar que esta simpleza ocasiona el doble trabajo de capturar mapeos a cada geom. Podemos introducir el concepto de mapeos globales y locales en ggplot.\nSi escribimos el mapeo dentro de ggplot() podemos asignar esos valores por defecto a todos los geoms que apilemos, haciendo necesario un solo cambio si deseamos editar la estética de dichos geoms. Veamos el uso del mapeo global:\n\nggplot(data = millas, mapping = aes(x = cilindrada, y = autopista, color = traccion)) +\n  geom_point() +\n  geom_smooth()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nAhora abordemos el uso de los mapeos locales. Estos permiten ampliar o sobrescribir los mapeos globales solo en la capa donde se colocan. Así es posible mostrar diferentes estéticas en cada geom.\n\nggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) +\n  geom_point(mapping = aes(color = clase)) +\n  geom_smooth()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nEn este ejemplo seguiremos teniendo los mismos ejes x y y en ambos geoms, pero solo aplicamos el cambio del color en geom_point().\nVeamos ahora otro ejemplo, pero cambiando el conjunto de datos a mostrar en uno de los geoms. En este caso, grafiquemos solo los coches subcompactos en la línea suavizada utilizando la función filter().\n\nggplot(data = millas, mapping = aes(x = cilindrada, y = autopista)) +\n  geom_point(mapping = aes(color = clase)) +\n  geom_smooth(data = filter(millas, clase == \"subcompacto\"), se = FALSE)\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nfilter() filtra los datos que le indicamos, especificando primero el conjunto de datos original y enseguida el criterio de filtrado.\n\n\nGráfico de barras\nVeamos ahora el gráfico de barras. Para ello, usaremos el conjunto de datos diamantes. Agruparemos por la variable corte.\n\nggplot(data = diamantes) +\n  stat_count(mapping = aes(x = corte))\n\n\n\n\nEs importante recordar que el geom_bar() calcula lo que grafica, contrario al gráfico de dispersión que sí toma los valores desde el propio conjunto de datos. Este proceso es conocido como transformación estadística (stat) y cada geom tiene el suyo asociado. En el caso del diagrama de barras, utiliza stat_count(). Esto significa que es posible utilizar indistintivamente el gráfico de barras o el conteo estadístico.\n\nggplot(data = diamantes) +\n  stat_count(mapping = aes(x = corte))\n\n\n\n\n¿Para qué querríamos utilizar la transformación estadística? Hay tres razones:\nEl gráfico de barras genera automáticamente los valores que grafica, por lo que las alturas de las barras no provienen de datos brutos. Es posible que deseemos graficar una variable con valores ya existentes. Por ejemplo, crearemos un subconjunto de datos y crearemos el gráfico a partir de este, cambiando la estadística recuento por identidad para que literalmente tome los valores y no los calcule:\n\nvalores_brutos <- tribble(\n  ~corte, ~freq,\n  \"Regular\", 1610,\n  \"Bueno\", 4906,\n  \"Muy Bueno\", 12082,\n  \"Premium\", 13791,\n  \"Ideal\", 21551\n)\n\nggplot(data = valores_brutos) +\n  geom_bar(mapping = aes(x = corte, y = freq), stat = \"identity\")\n\n\n\n\nNo nos preocupemos ni por tribble() ni por <-. Solo los usamos para crear la tabla que contiene los datos necesarios para el ejemplo, más tarde ahondaremos en ellos.\nPuede ser que deseamos cambiar el mapeo por defecto a uno de proporciones, por ejemplo.\n\nggplot(data = diamantes) +\n  geom_bar(mapping = aes(x = corte, y = stat(prop), group = 1))\n\nWarning: `stat(prop)` was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(prop)` instead.\n\n\n\n\n\nDeseamos resaltar un resumen estadístico de los datos, más allá de solo mostrarlos en un gráfico.\n\nggplot(data = diamantes) +\n  stat_summary(\n    mapping = aes(x = corte, y = profundidad),\n    fun.min = min,\n    fun.max = max,\n    fun = median\n  )\n\n\n\n\nPodemos colorear los gráficos de barras utilizando la estética fill:\n\nggplot(data = diamantes) +\n  geom_bar(mapping = aes(x = corte, fill = corte))"
  },
  {
    "objectID": "R4DS_view.html#sistemas-de-coordenadas",
    "href": "R4DS_view.html#sistemas-de-coordenadas",
    "title": "Visualización de datos - R4DS",
    "section": "Sistemas de coordenadas",
    "text": "Sistemas de coordenadas\nPosiblemente sea la parte más compleja de ggplot. En ocasiones desearemos intercambiar ejes, mejorar el aspecto de ciertos gráficos o utilizar coordenadas polares.\n\nIntercambiar ejes\nVeamos un gráfico de caja como aparece por defecto:\n\nggplot(data = millas, mapping = aes(x = clase, y = autopista)) +\n  geom_boxplot()\n\n\n\n\nCambiemos los ejes, para ello se usa coord_flip():\n\nggplot(data = millas, mapping = aes(x = clase, y = autopista)) +\n  geom_boxplot() +\n  coord_flip()\n\n\n\n\n\n\nAjuste de mapas\nPor si en algún momento debemos graficar mapas, es posible que no salgan bien representados.\n\nlibrary(maps)\n\n\nAttaching package: 'maps'\n\n\nThe following object is masked from 'package:purrr':\n\n    map\n\nnz <- map_data(\"nz\")\n\nggplot(nz, aes(long, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\")\n\n\n\n\nPodemos arreglar sus proporciones de la siguiente manera:\n\nggplot(nz, aes(long, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\") +\n  coord_quickmap()\n\n\n\n\n\n\nCoordenadas polares\nPodemos intercambiar las coordenadas cartesianas a polares, usando el siguiente código que muestra la relación entre dos tipos de gráfico:\n\nbar <- ggplot(data = diamantes) +\n  geom_bar(\n    mapping = aes(x = corte, fill = corte),\n    show.legend = FALSE,\n    width = 1\n  ) +\n  theme(aspect.ratio = 1) +\n  labs(x = NULL, y = NULL)\n\nbar + coord_flip()\n\n\n\nbar + coord_polar()"
  },
  {
    "objectID": "DC_view.html#estéticas-visibles",
    "href": "DC_view.html#estéticas-visibles",
    "title": "Visualización de datos - DC",
    "section": "Estéticas visibles",
    "text": "Estéticas visibles\nYa hemos visto que los ejes cartesianos son estéticas, al igual que otras características como el color o la transparencia. Hay más. Veamos cuáles son y hagamos unas cuantas aclaraciones.\nTenemos size, que se refiere al grosor de los puntos y líneas. Mientras que es importante saber que color es para definir el color de líneas y puntos o el contorno de las figuras más complejas. Si deseamos modificar el color de relleno de estas figuras, debemos utilizar fill. Si por lo contrario, queremos modificar el tipo de línea, utilizamos la estética linetype. Para modificar el texto en los ejes o gráficos usaremos la estética label y para finalizar, mencionemos shape, que permite cambiar la forma de los puntos.\n\ncolor, shape and size\nVolvamos a nuestro conjunto de datos llamado mtcars para aplicar las estéticas a una de sus variables, la categórica cyl. Estas estéticas van incluidas en aes() y cabe decir que por convención no es necesario nombrar los argumentos x y y. Sin embargo, lo seguiremos haciendo por claridad.\nNo olvidemos que la variable cyl es categórica pero la usaremos como factor. Creemos un gráfico de dispersión con wt como la variable independiente, mpg como la dependiente y fcyl como la estética color.\n\nggplot(data = mtcars, mapping = aes(x = wt, y = mpg, color = factor(cyl))) +\n  geom_point()\n\n\n\n\nAgreguemos un par de estéticas más: shape y size pero en este caso serán aplicadas a la geometría. Les daremos los valores de 1 y 4, respectivamente.\n\nggplot(data = mtcars, mapping = aes(x = wt, y = mpg, color = factor(cyl))) +\n  geom_point(shape = 1, size = 4)\n\n\n\n\n\n\ncolor contra fill\nYa se mencionó antes que la estética color modifica el contorno de una geometría y fill cambia el relleno de la misma. El gráfico de dispersión, al trabajar con puntos, asume que estos no cuentan con relleno, a menos que se modifique la figura de los mismos. Por defecto, la forma shape del punto es 19 y esta solo admite cambios en el contorno. Sin embargo, si cambiamos shape = 21 podremos cambiar el relleno también.\nTrabajemos con las variables cyl y am convertidas a factores y hagamos que la primera se refiera ahora a fill y no a color, además de modificar la forma a 21 y agreguemos una transparencia de 0.6.\n\nggplot(data = mtcars, mapping = aes(x = wt, y = mpg, fill = factor(cyl))) +\n  geom_point(shape = 21, size = 4, alpha = 0.6)"
  }
]